// Monitrax Database Schema
// This is the single source of truth for all financial data

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
// ENUMS
// =============================================================================

enum PropertyType {
  HOME
  INVESTMENT
}

enum LoanType {
  HOME
  INVESTMENT
}

enum RateType {
  VARIABLE
  FIXED
}

enum RepaymentFrequency {
  WEEKLY
  FORTNIGHTLY
  MONTHLY
}

enum AccountType {
  OFFSET
  SAVINGS
  TRANSACTIONAL
  CREDIT_CARD
}

enum IncomeType {
  SALARY
  RENT
  RENTAL
  INVESTMENT
  OTHER
}

enum ExpenseCategory {
  HOUSING
  RATES
  INSURANCE
  MAINTENANCE
  PERSONAL
  UTILITIES
  FOOD
  TRANSPORT
  ENTERTAINMENT
  STRATA
  LAND_TAX
  LOAN_INTEREST
  OTHER
}

enum Frequency {
  WEEKLY
  FORTNIGHTLY
  MONTHLY
  ANNUAL
}

enum TransactionDirection {
  IN
  OUT
}

enum UserRole {
  OWNER       // Full permissions, billing, member management
  ADMIN       // Manage users and data, no billing/org deletion
  CONTRIBUTOR // Full access to financial entities, no user management
  VIEWER      // Read-only access

  // Legacy roles - kept for backward compatibility during migration
  PARTNER     // @deprecated - use CONTRIBUTOR instead
  ACCOUNTANT  // @deprecated - use VIEWER instead
}

enum DebtStrategy {
  TAX_AWARE_MINIMUM_INTEREST
  AVALANCHE
  SNOWBALL
}

// =============================================================================
// PHASE 5: SOURCE TYPE ENUMS
// =============================================================================

enum IncomeSourceType {
  GENERAL
  PROPERTY
  INVESTMENT
}

enum ExpenseSourceType {
  GENERAL
  PROPERTY
  LOAN
  INVESTMENT
}

// =============================================================================
// PHASE 10: AUTH & SECURITY ENUMS
// =============================================================================

enum MFAType {
  TOTP        // Google Authenticator, Authy
  SMS         // SMS fallback
  WEBAUTHN    // FIDO2, Passkeys, hardware keys
}

enum AuditAction {
  // Auth
  LOGIN
  LOGOUT
  MFA_CHALLENGE
  MFA_SUCCESS
  MFA_FAILURE
  PASSWORD_CHANGE
  PASSWORD_RESET

  // Passkey / WebAuthn
  PASSKEY_REGISTER
  PASSKEY_UPDATE
  PASSKEY_DELETE

  // CRUD operations
  CREATE
  READ
  UPDATE
  DELETE

  // Special operations
  EXPORT
  BULK_DELETE

  // Admin operations
  ROLE_CHANGE
  ORG_MEMBER_ADD
  ORG_MEMBER_REMOVE
  ORG_SETTINGS_UPDATE
  SESSION_REVOKE
  ACCOUNT_LOCK
  ACCOUNT_UNLOCK
  ACCOUNT_LOCKED
  ACCOUNT_UNLOCKED

  // Security
  RATE_LIMIT_HIT
  UNAUTHORIZED_ACCESS
  FORBIDDEN_ACCESS
}

enum AuditStatus {
  SUCCESS
  FAILURE
  BLOCKED
}

// =============================================================================
// PHASE 20: AUSTRALIAN TAX INTELLIGENCE ENGINE ENUMS
// =============================================================================

enum SalaryType {
  GROSS     // Before tax
  NET       // After tax (take-home)
}

enum PayFrequency {
  WEEKLY
  FORTNIGHTLY
  MONTHLY
  QUARTERLY
  ANNUALLY
}

enum TaxCategory {
  // Employment Income
  SALARY_WAGES           // Fully taxable
  ALLOWANCES             // Taxable unless specific exemptions
  BONUSES                // Fully taxable
  TERMINATION            // Special tax treatment

  // Investment Income
  DIVIDENDS_FRANKED      // Taxable with franking credits
  DIVIDENDS_UNFRANKED    // Fully taxable
  INTEREST               // Fully taxable
  CAPITAL_GAINS          // CGT rules apply

  // Property Income
  RENTAL                 // Fully taxable

  // Government Payments
  GOVERNMENT_TAXABLE     // Most are taxable
  GOVERNMENT_EXEMPT      // Some are exempt

  // Other
  GIFTS                  // Generally exempt
  INHERITANCE            // Generally exempt
  INSURANCE_PAYOUT       // Generally exempt
  HOBBY_INCOME           // May be taxable if profit-making

  // Exempt
  TAX_EXEMPT             // Confirmed exempt
}

enum SuperContributionType {
  EMPLOYER_SG           // Super Guarantee (mandatory)
  SALARY_SACRIFICE      // Pre-tax voluntary
  PERSONAL_DEDUCTIBLE   // Personal contribution claiming deduction
  PERSONAL_NON_DEDUCT   // After-tax personal contribution
  SPOUSE                // Spouse contribution
  GOVERNMENT_COCONTRIB  // Government co-contribution
  DOWNSIZER             // Downsizer contribution (65+)
}

// =============================================================================
// USER
// =============================================================================

model User {
  id                String    @id @default(uuid())
  email             String    @unique
  password          String?   // Nullable for passwordless accounts
  name              String
  role              UserRole  @default(OWNER)
  emailVerified     Boolean   @default(false)
  emailVerifiedAt   DateTime?
  mfaEnabled        Boolean   @default(false)
  mfaEnforcedByOrg  Boolean   @default(false)
  accountLocked     Boolean   @default(false)
  accountLockedUntil DateTime?
  lastLoginAt       DateTime?
  lastLoginIp       String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relationships
  properties          Property[]
  loans               Loan[]
  accounts            Account[]
  income              Income[]
  expenses            Expense[]
  transactions        Transaction[]
  debtPlans           DebtPlan[]
  investmentAccounts  InvestmentAccount[]

  // Phase 10: Auth & Security
  organizationMemberships OrganizationMember[]
  mfaMethods              MFAMethod[]
  sessions                UserSession[]
  auditLogs               AuditLog[]
  passkeyCredentials      PasskeyCredential[]
  magicLinks              MagicLink[]
  oauthAccounts           OAuthAccount[]
  loginAttempts           LoginAttempt[]
  emailMFACodes           EmailMFACode[]

  // Phase 11: AI Strategy Engine
  strategyRecommendations StrategyRecommendation[]
  strategySessions        StrategySession[]
  strategyForecasts       StrategyForecast[]

  // Phase 13: Transactional Intelligence
  unifiedTransactions     UnifiedTransaction[]
  recurringPayments       RecurringPayment[]
  spendingProfile         SpendingProfile?

  // Phase 14: Cashflow Optimisation Engine
  cashflowForecasts       CashflowForecast[]
  cashflowInsights        CashflowInsight[]
  cashflowStrategies      CashflowStrategy[]

  // Phase 18: Bank Transaction Import
  bankImportFiles         BankImportFile[]
  budgetTargets           BudgetTarget[]

  // Phase 19: Document Management
  documents               Document[]
  storageProviderConfig   StorageProviderConfig?

  // Phase 20: Australian Tax Intelligence Engine
  superannuationAccounts  SuperannuationAccount[]
  taxPositions            TaxPosition[]

  @@map("users")
}

// =============================================================================
// PROPERTY
// =============================================================================

model Property {
  id             String       @id @default(uuid())
  userId         String
  name           String
  type           PropertyType
  address        String?
  purchasePrice  Float
  purchaseDate   DateTime
  currentValue   Float
  valuationDate  DateTime
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relationships
  user                  User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  loans                 Loan[]
  income                Income[]
  expenses              Expense[]
  depreciationSchedules DepreciationSchedule[]

  @@index([userId])
  @@map("properties")
}

// =============================================================================
// LOAN
// =============================================================================

model Loan {
  id                   String              @id @default(uuid())
  userId               String
  propertyId           String?
  offsetAccountId      String?             @unique
  name                 String
  type                 LoanType
  principal            Float               // Current balance
  interestRateAnnual   Float               // e.g., 0.0625 for 6.25%
  rateType             RateType
  fixedExpiry          DateTime?           // When fixed rate expires
  isInterestOnly       Boolean             @default(false)
  termMonthsRemaining  Int
  minRepayment         Float               // Current required payment
  repaymentFrequency   RepaymentFrequency
  extraRepaymentCap    Float?              // Annual cap for extra repayments on fixed loans
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt

  // Relationships
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  property       Property?    @relation(fields: [propertyId], references: [id], onDelete: SetNull)
  offsetAccount  Account?     @relation(fields: [offsetAccountId], references: [id], onDelete: SetNull)
  expenses       Expense[]
  debtPlanLoans  DebtPlanLoan[]

  @@index([userId])
  @@index([propertyId])
  @@map("loans")
}

// =============================================================================
// ACCOUNT
// =============================================================================

model Account {
  id             String       @id @default(uuid())
  userId         String
  name           String
  type           AccountType
  institution    String?
  currentBalance Float
  interestRate   Float?       // Annual interest rate (e.g., 0.025 for 2.5%)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relationships
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions Transaction[]
  linkedLoan   Loan?         // One-to-one: this account can be an offset for one loan

  // Phase 13: Transactional Intelligence
  unifiedTransactions UnifiedTransaction[] @relation("UnifiedTransactions")
  recurringPayments   RecurringPayment[]   @relation("RecurringPayments")

  // Phase 14: Cashflow Optimisation Engine
  cashflowForecasts   CashflowForecast[]

  @@index([userId])
  @@map("accounts")
}

// =============================================================================
// INCOME
// =============================================================================

model Income {
  id                    String            @id @default(uuid())
  userId                String
  propertyId            String?
  investmentAccountId   String?
  name                  String
  type                  IncomeType
  sourceType            IncomeSourceType  @default(GENERAL)
  amount                Float
  frequency             Frequency

  // Phase 20: Salary-specific fields (only applicable when type = SALARY)
  salaryType            SalaryType?       // GROSS or NET (null for non-salary)
  payFrequency          PayFrequency?     // Pay cycle frequency

  // Phase 20: Calculated fields for salary
  grossAmount           Float?            // If NET entered, calculated GROSS
  netAmount             Float?            // If GROSS entered, calculated NET
  paygWithholding       Float?            // Calculated PAYG withholding (annual)

  // Phase 20: Superannuation (for SALARY type)
  superGuaranteeRate    Float?            // e.g., 0.115 for 11.5%
  superGuaranteeAmount  Float?            // Calculated SG amount (annual)
  salarySacrifice       Float?            // Pre-tax super sacrifice (annual)

  // Phase 20: Tax determination (auto-calculated, replaces isTaxable)
  taxCategory           TaxCategory?      // System-determined category
  taxableAmount         Float?            // The taxable portion
  taxExemptAmount       Float?            // Any exempt portion
  frankingCredits       Float?            // For dividends
  frankingPercentage    Float?            // Franking percentage (0-100)
  taxNotes              String?           // Explanation of tax treatment

  // Legacy field - kept for backward compatibility, will be deprecated
  isTaxable             Boolean           @default(true)

  startDate             DateTime?
  endDate               DateTime?
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  // Relationships
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  property          Property?          @relation(fields: [propertyId], references: [id], onDelete: SetNull)
  investmentAccount InvestmentAccount? @relation(fields: [investmentAccountId], references: [id], onDelete: SetNull)
  transactions      Transaction[]
  superContributions SuperContribution[]

  @@index([userId])
  @@index([propertyId])
  @@index([investmentAccountId])
  @@map("income")
}

// =============================================================================
// EXPENSE
// =============================================================================

model Expense {
  id                    String             @id @default(uuid())
  userId                String
  propertyId            String?
  loanId                String?
  investmentAccountId   String?
  name                  String
  vendorName            String?
  category              ExpenseCategory
  sourceType            ExpenseSourceType  @default(GENERAL)
  amount                Float
  frequency             Frequency
  isEssential           Boolean            @default(true)
  isTaxDeductible       Boolean            @default(false)
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt

  // Relationships
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  property          Property?          @relation(fields: [propertyId], references: [id], onDelete: SetNull)
  loan              Loan?              @relation(fields: [loanId], references: [id], onDelete: SetNull)
  investmentAccount InvestmentAccount? @relation(fields: [investmentAccountId], references: [id], onDelete: SetNull)
  transactions      Transaction[]

  @@index([userId])
  @@index([propertyId])
  @@index([loanId])
  @@index([investmentAccountId])
  @@map("expenses")
}

// =============================================================================
// TRANSACTION
// =============================================================================

model Transaction {
  id          String               @id @default(uuid())
  userId      String
  accountId   String
  propertyId  String?
  loanId      String?
  incomeId    String?
  expenseId   String?
  date        DateTime
  description String
  amount      Float
  direction   TransactionDirection
  category    String?
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt

  // Relationships
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  account  Account   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  income   Income?   @relation(fields: [incomeId], references: [id], onDelete: SetNull)
  expense  Expense?  @relation(fields: [expenseId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([accountId])
  @@index([date])
  @@map("transactions")
}

// =============================================================================
// DEBT PLAN (Optional storage of debt planner results)
// =============================================================================

model DebtPlan {
  id                    String        @id @default(uuid())
  userId                String
  name                  String
  strategy              DebtStrategy
  surplusPerPeriod      Float
  surplusFrequency      Frequency
  emergencyBuffer       Float         @default(0)
  respectFixedCaps      Boolean       @default(true)
  rolloverRepayments    Boolean       @default(true)
  totalInterestPaid     Float
  totalInterestSaved    Float
  debtFreeDate          DateTime?
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  // Relationships
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  loanDetails DebtPlanLoan[]

  @@index([userId])
  @@map("debt_plans")
}

// =============================================================================
// DEBT PLAN LOAN (Per-loan results from debt planner)
// =============================================================================

model DebtPlanLoan {
  id                String    @id @default(uuid())
  debtPlanId        String
  loanId            String
  loanName          String
  originalPrincipal Float
  payoffDate        DateTime
  totalInterestPaid Float
  monthsSaved       Int
  interestSaved     Float
  createdAt         DateTime  @default(now())

  // Relationships
  debtPlan DebtPlan @relation(fields: [debtPlanId], references: [id], onDelete: Cascade)
  loan     Loan     @relation(fields: [loanId], references: [id], onDelete: Cascade)

  @@index([debtPlanId])
  @@index([loanId])
  @@map("debt_plan_loans")
}

// =============================================================================
// PHASE 3: INVESTMENT ENUMS
// =============================================================================

enum InvestmentAccountType {
  BROKERAGE
  SUPERS
  FUND
  TRUST
  ETF_CRYPTO
}

enum HoldingType {
  SHARE
  ETF
  MANAGED_FUND
  CRYPTO
}

enum InvestmentTransactionType {
  BUY
  SELL
  DIVIDEND
  DISTRIBUTION
  DRP
}

enum DepreciationCategory {
  DIV40
  DIV43
}

enum DepreciationMethod {
  PRIME_COST
  DIMINISHING_VALUE
}

// =============================================================================
// PHASE 3: INVESTMENT ACCOUNT
// =============================================================================

model InvestmentAccount {
  id           String                @id @default(uuid())
  userId       String
  name         String
  type         InvestmentAccountType
  platform     String?               // e.g. CommSec, SelfWealth, Betashares app
  currency     String                @default("AUD")
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt

  // Relationships
  user         User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  holdings     InvestmentHolding[]
  transactions InvestmentTransaction[]
  incomes      Income[]
  expenses     Expense[]

  @@index([userId])
  @@map("investment_accounts")
}

// =============================================================================
// PHASE 3: INVESTMENT HOLDING
// =============================================================================

model InvestmentHolding {
  id                  String            @id @default(uuid())
  investmentAccountId String
  ticker              String            // VAS, A200, VGS, BHP
  units               Float
  averagePrice        Float
  frankingPercentage  Float?            // AU feature for franking credits
  type                HoldingType
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  // Relationships
  investmentAccount   InvestmentAccount       @relation(fields: [investmentAccountId], references: [id], onDelete: Cascade)
  transactions        InvestmentTransaction[]

  @@index([investmentAccountId])
  @@map("investment_holdings")
}

// =============================================================================
// PHASE 3: INVESTMENT TRANSACTION
// =============================================================================

model InvestmentTransaction {
  id                  String                    @id @default(uuid())
  investmentAccountId String
  holdingId           String?
  date                DateTime
  type                InvestmentTransactionType
  price               Float
  units               Float
  fees                Float?
  notes               String?
  createdAt           DateTime                  @default(now())
  updatedAt           DateTime                  @updatedAt

  // Relationships
  investmentAccount   InvestmentAccount   @relation(fields: [investmentAccountId], references: [id], onDelete: Cascade)
  holding             InvestmentHolding?  @relation(fields: [holdingId], references: [id], onDelete: SetNull)

  @@index([investmentAccountId])
  @@index([holdingId])
  @@map("investment_transactions")
}

// =============================================================================
// PHASE 3: DEPRECIATION SCHEDULE
// =============================================================================

model DepreciationSchedule {
  id         String               @id @default(uuid())
  propertyId String
  category   DepreciationCategory
  assetName  String
  cost       Float
  startDate  DateTime
  rate       Float                // 2.5% for Div43, or effective life rate
  method     DepreciationMethod   // PRIME_COST | DIMINISHING_VALUE
  notes      String?
  createdAt  DateTime             @default(now())
  updatedAt  DateTime             @updatedAt

  // Relationships
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@index([propertyId])
  @@map("depreciation_schedules")
}

// =============================================================================
// PHASE 10: ORGANIZATION & MULTI-TENANT
// =============================================================================

model Organization {
  id                    String               @id @default(uuid())
  name                  String
  slug                  String               @unique
  description           String?
  mfaEnforced           Boolean              @default(false)
  sessionDurationHours  Int                  @default(168) // 7 days
  allowedDomains        String[]             // Email domain restrictions
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt

  // Relationships
  members               OrganizationMember[]
  auditLogs             AuditLog[]
  strategyRecommendations StrategyRecommendation[]

  @@map("organizations")
}

model OrganizationMember {
  id             String        @id @default(uuid())
  organizationId String
  userId         String
  role           UserRole      @default(VIEWER)
  invitedBy      String?       // User ID who sent the invitation
  invitedAt      DateTime      @default(now())
  joinedAt       DateTime?
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // Relationships
  organization   Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId])
  @@index([organizationId])
  @@index([userId])
  @@map("organization_members")
}

// =============================================================================
// PHASE 10: MFA & AUTHENTICATION
// =============================================================================

model MFAMethod {
  id              String    @id @default(uuid())
  userId          String
  type            MFAType
  isEnabled       Boolean   @default(true)
  isPrimary       Boolean   @default(false)
  secret          String?   // For TOTP: encrypted secret
  phoneNumber     String?   // For SMS: phone number
  backupCodes     String[]  // Encrypted backup codes
  lastUsedAt      DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relationships
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("mfa_methods")
}

model PasskeyCredential {
  id                String    @id @default(uuid())
  userId            String
  credentialId      String    @unique // WebAuthn credential ID
  publicKey         String    // Public key for verification
  counter           Int       @default(0)
  deviceName        String?
  transports        String[]  // e.g., ["usb", "nfc", "ble"]
  lastUsedAt        DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relationships
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("passkey_credentials")
}

model UserSession {
  id              String    @id @default(uuid())
  userId          String
  token           String    @unique
  deviceName      String?
  deviceFingerprint String?
  ipAddress       String?
  userAgent       String?
  isActive        Boolean   @default(true)
  expiresAt       DateTime
  lastActivityAt  DateTime  @default(now())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relationships
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("user_sessions")
}

// =============================================================================
// PHASE 10: AUDIT LOGGING
// =============================================================================

model AuditLog {
  id              String         @id @default(uuid())
  userId          String?
  organizationId  String?
  action          AuditAction
  status          AuditStatus    @default(SUCCESS)
  entityType      String?        // "Property", "Loan", "User", etc.
  entityId        String?        // ID of the affected entity
  ipAddress       String?
  userAgent       String?
  metadata        Json?          // Additional context (old/new values, error details)
  createdAt       DateTime       @default(now())

  // Relationships
  user            User?          @relation(fields: [userId], references: [id], onDelete: SetNull)
  organization    Organization?  @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([organizationId])
  @@index([action])
  @@index([createdAt])
  @@index([entityType, entityId])
  @@map("audit_logs")
}

// =============================================================================
// PHASE 10: MAGIC LINK AUTHENTICATION
// =============================================================================

model MagicLink {
  id          String    @id @default(uuid())
  userId      String
  token       String    @unique
  email       String
  expiresAt   DateTime
  usedAt      DateTime?
  redirectTo  String?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime  @default(now())

  // Relationships
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("magic_links")
}

// =============================================================================
// PHASE 10: OAUTH ACCOUNTS
// =============================================================================

model OAuthAccount {
  id              String    @id @default(uuid())
  userId          String
  provider        String    // google, apple, microsoft
  providerUserId  String    // ID from OAuth provider
  email           String?
  accessToken     String?   @db.Text
  refreshToken    String?   @db.Text
  expiresAt       DateTime?
  scope           String?
  tokenType       String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relationships
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerUserId])
  @@index([userId])
  @@map("oauth_accounts")
}
// =============================================================================
// PHASE 10: LOGIN ATTEMPTS (for account lockout)
// =============================================================================

model LoginAttempt {
  id          String    @id @default(uuid())
  userId      String
  email       String
  success     Boolean
  ipAddress   String?
  userAgent   String?
  attemptedAt DateTime  @default(now())

  // Relationships
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([email])
  @@index([attemptedAt])
  @@map("login_attempts")
}

// =============================================================================
// PHASE 10: EMAIL MFA CODES
// =============================================================================

model EmailMFACode {
  id          String    @id @default(uuid())
  userId      String
  code        String    // SHA-256 hashed
  expiresAt   DateTime
  verified    Boolean   @default(false)
  verifiedAt  DateTime?
  attempts    Int       @default(0)
  createdAt   DateTime  @default(now())

  // Relationships
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([code])
  @@index([expiresAt])
  @@map("email_mfa_codes")
}

// =============================================================================
// PHASE 13: TRANSACTIONAL INTELLIGENCE ENUMS
// =============================================================================

enum TransactionSource {
  BANK        // Bank feed integration
  CSV         // CSV import
  OFX         // OFX/QFX file import
  MANUAL      // Manual entry
}

enum RecurrencePattern {
  WEEKLY
  FORTNIGHTLY
  MONTHLY
  QUARTERLY
  ANNUALLY
  IRREGULAR
}

enum AnomalyType {
  DUPLICATE           // Possible duplicate transaction
  UNUSUAL_AMOUNT      // Amount significantly differs from pattern
  NEW_MERCHANT        // First time seeing this merchant
  PRICE_INCREASE      // Recurring payment increased
  UNEXPECTED_CATEGORY // Category doesn't match merchant history
  TIMING_ANOMALY      // Transaction at unusual time/day
}

// =============================================================================
// PHASE 13: UNIFIED TRANSACTION RECORD (UTR)
// =============================================================================

model UnifiedTransaction {
  id                    String               @id @default(uuid())
  userId                String
  accountId             String

  // Core transaction data
  date                  DateTime
  postDate              DateTime?            // Settlement date
  amount                Float
  currency              String               @default("AUD")
  direction             TransactionDirection

  // Merchant data
  merchantRaw           String?              // Original merchant string from source
  merchantStandardised  String?              // Normalised merchant name
  merchantCategoryCode  String?              // MCC code if available
  description           String               // Transaction description

  // Category hierarchy (AI + rules populated)
  categoryLevel1        String?              // Top-level: "Food & Dining"
  categoryLevel2        String?              // Sub-category: "Groceries"
  subcategory           String?              // Detailed: "Supermarket"

  // User interaction
  tags                  String[]             // User/system tags
  userCorrectedCategory Boolean              @default(false)
  confidenceScore       Float?               // AI categorisation confidence (0-1)

  // Recurring detection
  isRecurring           Boolean              @default(false)
  recurrencePattern     RecurrencePattern?
  recurrenceGroupId     String?              // Links recurring transactions together

  // Anomaly detection
  anomalyFlags          AnomalyType[]

  // Source tracking
  source                TransactionSource    @default(MANUAL)
  externalId            String?              // ID from external source (bank, CSV row)
  importBatchId         String?              // Batch ID for grouped imports

  // Entity linking (GRDCS compatible)
  propertyId            String?
  loanId                String?
  incomeId              String?
  expenseId             String?
  investmentAccountId   String?

  // Metadata
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
  processedAt           DateTime?            // When TIE last processed this

  // Relationships
  user                  User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  account               Account              @relation("UnifiedTransactions", fields: [accountId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([accountId])
  @@index([date])
  @@index([merchantStandardised])
  @@index([categoryLevel1])
  @@index([isRecurring])
  @@index([recurrenceGroupId])
  @@index([source])
  @@index([processedAt])
  @@map("unified_transactions")
}

// =============================================================================
// PHASE 13: MERCHANT MAPPING (Learning from corrections)
// =============================================================================

model MerchantMapping {
  id                    String    @id @default(uuid())
  userId                String?   // Null = global mapping, set = user-specific

  // Merchant identification
  merchantRaw           String    // Original merchant string pattern
  merchantStandardised  String    // Normalised name
  merchantCategoryCode  String?   // MCC if known

  // Category mapping
  categoryLevel1        String
  categoryLevel2        String?
  subcategory           String?

  // Learning metadata
  confidence            Float     @default(1.0)   // How confident this mapping is
  source                String    @default("RULE") // RULE, USER, AI
  usageCount            Int       @default(0)     // How many times applied

  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@unique([userId, merchantRaw])
  @@index([merchantRaw])
  @@index([userId])
  @@map("merchant_mappings")
}

// =============================================================================
// PHASE 13: RECURRING PAYMENT DETECTION
// =============================================================================

model RecurringPayment {
  id                    String            @id @default(uuid())
  userId                String

  // Identification
  merchantStandardised  String
  accountId             String

  // Pattern
  pattern               RecurrencePattern
  expectedAmount        Float
  amountVariance        Float             @default(0.05) // 5% variance tolerance

  // Tracking
  lastOccurrence        DateTime
  nextExpected          DateTime?
  occurrenceCount       Int               @default(0)

  // Alerts
  priceIncreaseAlert    Boolean           @default(false)
  lastPriceChange       Float?
  lastPriceChangeDate   DateTime?

  // Status
  isActive              Boolean           @default(true)
  isPaused              Boolean           @default(false)

  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  // Relationships
  user                  User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  account               Account           @relation("RecurringPayments", fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([userId, merchantStandardised, accountId])
  @@index([userId])
  @@index([accountId])
  @@index([nextExpected])
  @@map("recurring_payments")
}

// =============================================================================
// PHASE 13: BEHAVIOURAL PROFILE
// =============================================================================

model SpendingProfile {
  id                    String    @id @default(uuid())
  userId                String    @unique

  // Category averages (JSON: { category: { avgMonthly, trend, volatility } })
  categoryAverages      Json

  // Monthly patterns (JSON: { month: { totalSpend, categories } })
  monthlyPatterns       Json?

  // Seasonality detection
  seasonalityFactors    Json?     // { category: { jan: 1.2, feb: 0.9, ... } }

  // Spending clusters (AI-detected patterns)
  spendingClusters      Json?     // [{ name, merchants, avgMonthly }]

  // Volatility metrics
  overallVolatility     Float     @default(0)
  categoryVolatility    Json?     // { category: volatilityScore }

  // Prediction data
  predictedMonthlySpend Float?
  predictionConfidence  Float?

  // Metadata
  dataPointCount        Int       @default(0)
  lastCalculated        DateTime  @default(now())
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relationships
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("spending_profiles")
}

// =============================================================================
// PHASE 14: CASHFLOW OPTIMISATION ENGINE ENUMS
// =============================================================================

enum CashflowInsightCategory {
  RECURRING           // Recurring payment insights
  ANOMALY             // Unusual spending detected
  INEFFICIENCY        // Wasteful spending identified
  LIQUIDITY_RISK      // Cash shortage risk
  SUBSCRIPTION        // Subscription-related insight
  SAVINGS_OPPORTUNITY // Potential savings found
}

enum CashflowStrategyType {
  OPTIMISE            // General optimisation
  PREVENT_SHORTFALL   // Avoid cash shortage
  MAXIMISE_OFFSET     // Maximise offset benefits
  REDUCE_WASTE        // Cut wasteful spending
  REBALANCE           // Rebalance cash allocation
  REPAYMENT_OPTIMISE  // Optimise loan repayments
  SCHEDULE_OPTIMISE   // Optimise payment scheduling
}

enum CashflowInsightSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// =============================================================================
// PHASE 11: AI STRATEGY ENGINE ENUMS
// =============================================================================

enum StrategyCategory {
  GROWTH
  DEBT
  CASHFLOW
  INVESTMENT
  PROPERTY
  RISK_RESILIENCE
}

enum StrategyType {
  TACTICAL        // Immediate action
  OPERATIONAL     // 3-12 months
  STRATEGIC       // 1-5 years
  LONG_TERM       // 5-30 years
}

enum RecommendationStatus {
  PENDING
  ACCEPTED
  DISMISSED
  EXPIRED
}

enum ConfidenceLevel {
  HIGH
  MEDIUM
  LOW
}

enum RiskAppetite {
  CONSERVATIVE
  MODERATE
  AGGRESSIVE
}

enum DebtComfort {
  DEBT_AVERSE
  MODERATE
  LEVERAGE_COMFORTABLE
}

enum InvestmentStyle {
  PASSIVE
  BALANCED
  ACTIVE
}

enum ScenarioType {
  DEFAULT
  CONSERVATIVE
  AGGRESSIVE
  CUSTOM
}

// =============================================================================
// PHASE 11: STRATEGY RECOMMENDATION
// =============================================================================

model StrategyRecommendation {
  id                String               @id @default(uuid())
  userId            String
  organizationId    String?

  // Classification
  category          StrategyCategory
  type              StrategyType
  severity          String               // 'critical' | 'high' | 'medium' | 'low' (from InsightSeverity)

  // Content
  title             String
  summary           String               @db.Text
  detail            String               @db.Text

  // Scoring
  sbsScore          Float                // Strategic Benefit Score (0-100)
  confidence        ConfidenceLevel

  // Impact Analysis (stored as JSON for flexibility)
  financialImpact   Json                 // { min, max, currency, timeframe, monthlySavings, totalSavings, breakEven }
  riskImpact        Json                 // { current, projected, factors[] }
  liquidityImpact   Json?                // { currentLiquidity, projectedLiquidity, impact }
  taxImpact         Json?                // { currentTax, projectedTax, savings }

  // Evidence & Explainability
  reasoning         String               @db.Text  // Step-by-step reasoning trace
  evidenceGraph     Json                 // { dataPoints[], historicalTrend[], snapshotValues, insightFlags[], healthIssues[], calculations }
  alternativeIds    String[]             // IDs of alternative strategies

  // Affected Entities (GRDCS format)
  affectedEntities  Json                 // GRDCSLinkedEntity[] - entities impacted by this recommendation

  // Forecast Projection (optional)
  forecastData      Json?                // Multi-year projection if applicable

  // User Interaction
  status            RecommendationStatus @default(PENDING)
  dismissedAt       DateTime?
  acceptedAt        DateTime?
  dismissReason     String?

  // Metadata
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  expiresAt         DateTime?            // When this recommendation becomes stale

  // Relationships
  user              User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization      Organization?        @relation(fields: [organizationId], references: [id])

  @@index([userId, status])
  @@index([organizationId])
  @@index([category, status])
  @@index([sbsScore])
  @@index([createdAt])
  @@map("strategy_recommendations")
}

// =============================================================================
// PHASE 11: STRATEGY SESSION (User Preferences)
// =============================================================================

model StrategySession {
  id                String            @id @default(uuid())
  userId            String

  version           Int               @default(1)

  // User Input Parameters
  riskAppetite      RiskAppetite?
  timeHorizon       Int?              // Years (e.g., 5, 10, 20, 30)
  debtComfort       DebtComfort?
  investmentStyle   InvestmentStyle?
  retirementAge     Int?              // Target retirement age

  // Scenario Selection
  scenarioType      ScenarioType      @default(DEFAULT)
  customParameters  Json?             // Custom forecast parameters if scenarioType = CUSTOM

  // Tracking
  acceptedCount     Int               @default(0)
  dismissedCount    Int               @default(0)

  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // Relationships
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("strategy_sessions")
}

// =============================================================================
// PHASE 11: STRATEGY FORECAST (Multi-Year Projections)
// =============================================================================

model StrategyForecast {
  id                String        @id @default(uuid())
  userId            String

  // Forecast Parameters
  startYear         Int           // Starting year (e.g., 2025)
  endYear           Int           // Ending year (e.g., 2055 for 30-year forecast)
  scenarioType      ScenarioType

  // Input Assumptions
  incomeGrowthRate  Float         // Annual income growth rate (e.g., 0.03 for 3%)
  expenseInflation  Float         // Annual expense inflation (e.g., 0.025 for 2.5%)
  investmentReturn  Float         // Expected annual investment return (e.g., 0.07 for 7%)
  rentalYield       Float         // Expected rental yield (e.g., 0.04 for 4%)
  cpiProjection     Float         // CPI inflation projection (e.g., 0.025 for 2.5%)

  // Yearly Projections (array of year data stored as JSON)
  projections       Json          // [{ year, netWorth, debt, cashflow, income, expenses, investments, properties }]

  // Risk Bands (best/worst case scenarios)
  worstCase         Json          // Worst case projection array
  bestCase          Json          // Best case projection array

  // Target Achievement
  targetProbability Float?        // Probability of achieving retirement/goal target (0-1)

  createdAt         DateTime      @default(now())

  // Relationships
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([scenarioType])
  @@index([createdAt])
  @@map("strategy_forecasts")
}

// =============================================================================
// PHASE 14: CASHFLOW FORECAST
// =============================================================================

model CashflowForecast {
  id                  String    @id @default(uuid())
  userId              String
  accountId           String?   // Null = global forecast across all accounts

  // Forecast date
  date                DateTime  // The date this forecast is for

  // Predicted values
  predictedBalance    Float     // Predicted balance on this date
  predictedIncome     Float     // Predicted income for this date
  predictedExpenses   Float     // Predicted expenses for this date

  // Confidence metrics
  confidenceScore     Float     // 0-1 confidence in this prediction
  volatilityFactor    Float     @default(0) // Volatility index (0 = stable)

  // Confidence bands (upper/lower bounds)
  upperBound          Float?    // Optimistic scenario
  lowerBound          Float?    // Pessimistic scenario

  // Additional metadata
  predictedRecurring  Float     @default(0) // Recurring payments expected
  predictedNonRecurring Float   @default(0) // Non-recurring expected
  shortfallRisk       Boolean   @default(false) // Is shortfall predicted?
  shortfallAmount     Float?    // Amount of predicted shortfall

  // Calculation metadata
  metadata            Json?     // { calculationMethod, inputCount, anomaliesDetected }

  // Timestamps
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relationships
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  account             Account?  @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([userId, accountId, date])
  @@index([userId])
  @@index([accountId])
  @@index([date])
  @@index([shortfallRisk])
  @@map("cashflow_forecasts")
}

// =============================================================================
// PHASE 14: CASHFLOW INSIGHT
// =============================================================================

model CashflowInsight {
  id                  String                    @id @default(uuid())
  userId              String

  // Classification
  severity            CashflowInsightSeverity
  category            CashflowInsightCategory

  // Content
  title               String
  description         String                    @db.Text
  recommendedAction   String                    @db.Text

  // Impact tracking
  impactedAccountIds  String[]                  // Account IDs affected
  impactedCategories  String[]                  // Spending categories affected

  // Financial estimate
  valueEstimate       Float?                    // Estimated dollar impact
  savingsPotential    Float?                    // Potential savings if actioned
  confidenceScore     Float                     @default(0.8) // 0-1

  // Linked entities (for GRDCS compatibility)
  linkedEntities      Json?                     // { loans: [], accounts: [], recurring: [] }

  // User interaction
  isRead              Boolean                   @default(false)
  isDismissed         Boolean                   @default(false)
  isActioned          Boolean                   @default(false)
  dismissedAt         DateTime?
  actionedAt          DateTime?

  // Validity
  expiresAt           DateTime?                 // When this insight becomes stale

  // Metadata
  metadata            Json?                     // Additional context
  createdAt           DateTime                  @default(now())
  updatedAt           DateTime                  @updatedAt

  // Relationships
  user                User                      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([severity])
  @@index([category])
  @@index([isRead, isDismissed])
  @@index([createdAt])
  @@map("cashflow_insights")
}

// =============================================================================
// PHASE 18: BANK TRANSACTION IMPORT
// =============================================================================

enum ImportFileFormat {
  CSV
  OFX
  QIF
  JSON
}

enum ImportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  PARTIAL
}

enum DuplicatePolicy {
  REJECT
  MARK_DUPLICATE
  MERGE
  SKIP
}

model BankImportFile {
  id                String           @id @default(uuid())
  userId            String

  // File info
  filename          String
  format            ImportFileFormat
  fileSize          Int              // Bytes
  fileHash          String           // SHA-256 of file content for duplicate detection

  // Import status
  status            ImportStatus     @default(PENDING)
  errorMessage      String?

  // Statistics
  totalRows         Int              @default(0)
  importedCount     Int              @default(0)
  duplicateCount    Int              @default(0)
  errorCount        Int              @default(0)

  // Settings used for this import
  accountId         String?          // Target account for import
  duplicatePolicy   DuplicatePolicy  @default(REJECT)
  dateFormat        String?          // Date format used in file

  // Timestamps
  uploadedAt        DateTime         @default(now())
  processedAt       DateTime?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  // Relationships
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  rawTransactions   BankTransactionRaw[]

  @@index([userId])
  @@index([fileHash])
  @@index([status])
  @@map("bank_import_files")
}

model BankTransactionRaw {
  id                String           @id @default(uuid())
  importFileId      String

  // Raw data from file
  rowNumber         Int              // Row number in source file
  rawData           Json             // Original row data as JSON

  // Parsed fields
  date              DateTime?
  description       String?
  amount            Float?
  direction         TransactionDirection?
  balance           Float?           // Running balance if provided
  reference         String?

  // Processing status
  isProcessed       Boolean          @default(false)
  isDuplicate       Boolean          @default(false)
  hasError          Boolean          @default(false)
  errorMessage      String?

  // Hash for duplicate detection
  transactionHash   String           // SHA-256(date + amount + description)

  // Link to normalised transaction if created
  unifiedTransactionId String?       @unique

  createdAt         DateTime         @default(now())

  // Relationships
  importFile        BankImportFile   @relation(fields: [importFileId], references: [id], onDelete: Cascade)

  @@index([importFileId])
  @@index([transactionHash])
  @@index([isProcessed])
  @@index([isDuplicate])
  @@map("bank_transactions_raw")
}

model CategoryRule {
  id                String    @id @default(uuid())
  userId            String?   // Null = system rule, set = user rule

  // Rule matching
  ruleType          String    // MERCHANT, KEYWORD, MCC, BPAY, AMOUNT_RANGE
  pattern           String    // Pattern to match (regex or exact)
  isRegex           Boolean   @default(false)
  caseSensitive     Boolean   @default(false)

  // Category assignment
  categoryLevel1    String
  categoryLevel2    String?
  subcategory       String?

  // Entity linking (optional)
  linkToPropertyId  String?
  linkToLoanId      String?
  linkToExpenseId   String?

  // Rule metadata
  priority          Int       @default(50)  // Higher = checked first
  isActive          Boolean   @default(true)
  matchCount        Int       @default(0)   // Times this rule matched

  // Audit
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([userId])
  @@index([ruleType])
  @@index([priority])
  @@index([isActive])
  @@map("category_rules")
}

model BudgetTarget {
  id                String    @id @default(uuid())
  userId            String

  // Category targeting
  categoryLevel1    String
  categoryLevel2    String?

  // Budget amounts
  monthlyTarget     Float     // Target monthly spend
  warningThreshold  Float     @default(0.8)  // Warn at 80% of target

  // Tracking period
  effectiveFrom     DateTime  @default(now())
  effectiveTo       DateTime?

  // Flexibility
  allowRollover     Boolean   @default(false)  // Can unspent roll to next month?
  isEssential       Boolean   @default(false)  // Is this an essential expense?

  // Notes
  notes             String?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relationships
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, categoryLevel1, categoryLevel2])
  @@index([userId])
  @@index([categoryLevel1])
  @@map("budget_targets")
}

// =============================================================================
// PHASE 14: CASHFLOW STRATEGY
// =============================================================================

model CashflowStrategy {
  id                  String                @id @default(uuid())
  userId              String

  // Strategy classification
  type                CashflowStrategyType
  priority            Int                   @default(50) // 1-100, higher = more important

  // Content
  title               String
  summary             String                @db.Text
  detail              String?               @db.Text

  // Scoring
  confidence          Float                 // 0-1 confidence in this strategy
  projectedBenefit    Float                 // Estimated dollar benefit

  // Implementation steps (JSON array)
  recommendedSteps    Json                  // [{ order, action, description, optional }]

  // Impact analysis
  impactAnalysis      Json?                 // { cashflowImpact, riskReduction, timeToRealize }

  // Affected entities
  affectedAccountIds  String[]
  affectedLoanIds     String[]
  affectedRecurringIds String[]

  // User interaction
  status              RecommendationStatus  @default(PENDING)
  acceptedAt          DateTime?
  dismissedAt         DateTime?
  dismissReason       String?

  // Validity
  expiresAt           DateTime?

  // Metadata
  metadata            Json?
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt

  // Relationships
  user                User                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([priority])
  @@index([createdAt])
  @@map("cashflow_strategies")
}

// =============================================================================
// PHASE 19: DOCUMENT MANAGEMENT ENUMS
// =============================================================================

enum DocumentCategory {
  CONTRACT
  STATEMENT
  RECEIPT
  TAX
  PDS           // Product Disclosure Statement
  VALUATION
  INSURANCE
  MORTGAGE
  LEASE
  INVOICE
  OTHER
}

enum StorageProviderType {
  MONITRAX
  GOOGLE_DRIVE
  // Future: ONEDRIVE, ICLOUD, S3
}

enum LinkedEntityType {
  PROPERTY
  LOAN
  EXPENSE
  INCOME
  ACCOUNT
  OFFSET_ACCOUNT
  INVESTMENT_ACCOUNT
  INVESTMENT_HOLDING
  TRANSACTION
}

// =============================================================================
// PHASE 19: DOCUMENT MODEL
// =============================================================================

model Document {
  id                String              @id @default(uuid())
  userId            String

  // File metadata
  filename          String              // Generated filename in storage
  originalFilename  String              // Original uploaded filename
  mimeType          String
  size              Int                 // Size in bytes
  category          DocumentCategory

  // Storage reference
  storageProvider   StorageProviderType @default(MONITRAX)
  storagePath       String              // Key/path in storage
  storageUrl        String?             // External URL for Google Drive etc.

  // User metadata
  description       String?
  tags              String[]

  // Timestamps
  uploadedAt        DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  deletedAt         DateTime?           // Soft delete

  // Relationships
  user              User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  links             DocumentLink[]

  @@index([userId])
  @@index([category])
  @@index([storageProvider])
  @@index([deletedAt])
  @@map("documents")
}

// =============================================================================
// PHASE 19: DOCUMENT LINK (Polymorphic Entity Linking)
// =============================================================================

model DocumentLink {
  id            String           @id @default(uuid())
  documentId    String
  entityType    LinkedEntityType
  entityId      String

  createdAt     DateTime         @default(now())

  // Relationships
  document      Document         @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, entityType, entityId])
  @@index([entityType, entityId])
  @@index([documentId])
  @@map("document_links")
}

// =============================================================================
// PHASE 19: STORAGE PROVIDER CONFIG (Per-user OAuth)
// =============================================================================

model StorageProviderConfig {
  id            String              @id @default(uuid())
  userId        String              @unique
  provider      StorageProviderType
  isActive      Boolean             @default(true)

  // Encrypted OAuth credentials
  accessToken   String?             @db.Text
  refreshToken  String?             @db.Text
  tokenExpiry   DateTime?

  // Provider-specific config (folder IDs, preferences, etc.)
  config        Json?

  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  // Relationships
  user          User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("storage_provider_configs")
}

// =============================================================================
// PHASE 20: SUPERANNUATION ACCOUNT
// =============================================================================

model SuperannuationAccount {
  id                    String   @id @default(uuid())
  userId                String

  // Account details
  name                  String
  fundName              String?
  memberNumber          String?
  fundABN               String?

  // Balances
  currentBalance        Float    @default(0)
  taxableComponent      Float    @default(0)
  taxFreeComponent      Float    @default(0)

  // Contribution tracking (current FY)
  concessionalYTD       Float    @default(0)   // SG + Salary Sacrifice + Personal deductible
  nonConcessionalYTD    Float    @default(0)   // After-tax contributions
  financialYear         String?               // e.g., "2024-25"

  // Contribution caps (updated annually)
  concessionalCap       Float    @default(27500)
  nonConcessionalCap    Float    @default(110000)

  // Carry-forward tracking (unused concessional caps from prior 5 years)
  carryForwardAvailable Float    @default(0)

  // Investment options / performance (optional)
  investmentOption      String?
  returns1Year          Float?
  returns5Year          Float?

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relationships
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  contributions         SuperContribution[]

  @@index([userId])
  @@map("superannuation_accounts")
}

// =============================================================================
// PHASE 20: SUPER CONTRIBUTION
// =============================================================================

model SuperContribution {
  id                    String                @id @default(uuid())
  superAccountId        String
  incomeId              String?               // Link to salary income if applicable

  type                  SuperContributionType
  amount                Float
  date                  DateTime
  financialYear         String                // e.g., "2024-25"

  // Additional tracking
  employerName          String?               // For SG contributions
  notes                 String?

  createdAt             DateTime              @default(now())

  // Relationships
  superAccount          SuperannuationAccount @relation(fields: [superAccountId], references: [id], onDelete: Cascade)
  income                Income?               @relation(fields: [incomeId], references: [id], onDelete: SetNull)

  @@index([superAccountId])
  @@index([incomeId])
  @@index([financialYear])
  @@map("super_contributions")
}

// =============================================================================
// PHASE 20: TAX POSITION (Annual Tax Summary)
// =============================================================================

model TaxPosition {
  id                    String   @id @default(uuid())
  userId                String
  financialYear         String   // e.g., "2024-25"

  // Income aggregation
  grossIncome           Float    @default(0)
  assessableIncome      Float    @default(0)

  // Income breakdown
  salaryIncome          Float    @default(0)
  rentalIncome          Float    @default(0)
  dividendIncome        Float    @default(0)
  interestIncome        Float    @default(0)
  capitalGains          Float    @default(0)
  otherIncome           Float    @default(0)

  // Deductions
  totalDeductions       Float    @default(0)
  workRelatedDeductions Float    @default(0)
  propertyDeductions    Float    @default(0)
  investmentDeductions  Float    @default(0)
  depreciationClaims    Float    @default(0)
  otherDeductions       Float    @default(0)

  // Taxable income
  taxableIncome         Float    @default(0)

  // Tax calculations
  taxOnIncome           Float    @default(0)
  medicareLevy          Float    @default(0)
  medicareSurcharge     Float    @default(0)

  // Tax offsets
  litoOffset            Float    @default(0)   // Low Income Tax Offset
  saptoOffset           Float    @default(0)   // Senior Australians
  frankingCreditsOffset Float    @default(0)
  foreignTaxCredits     Float    @default(0)
  otherOffsets          Float    @default(0)

  // Final position
  totalTaxPayable       Float    @default(0)
  totalPaygWithheld     Float    @default(0)
  estimatedRefund       Float    @default(0)   // Positive = refund, Negative = owing

  // Super contributions (for reference)
  superContributions    Float    @default(0)
  division293Tax        Float    @default(0)   // High earner super tax

  // Metadata
  calculatedAt          DateTime @default(now())
  isProjection          Boolean  @default(true) // false when actual lodgement

  // Relationships
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, financialYear])
  @@index([userId])
  @@index([financialYear])
  @@map("tax_positions")
}
