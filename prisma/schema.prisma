// Monitrax Database Schema
// This is the single source of truth for all financial data

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
// ENUMS
// =============================================================================

enum PropertyType {
  HOME
  INVESTMENT
}

enum LoanType {
  HOME
  INVESTMENT
}

enum RateType {
  VARIABLE
  FIXED
}

enum RepaymentFrequency {
  WEEKLY
  FORTNIGHTLY
  MONTHLY
}

enum AccountType {
  OFFSET
  SAVINGS
  TRANSACTIONAL
  CREDIT_CARD
}

enum IncomeType {
  SALARY
  RENT
  RENTAL
  INVESTMENT
  OTHER
}

enum ExpenseCategory {
  HOUSING
  RATES
  INSURANCE
  MAINTENANCE
  PERSONAL
  UTILITIES
  FOOD
  TRANSPORT
  ENTERTAINMENT
  STRATA
  LAND_TAX
  LOAN_INTEREST
  OTHER
}

enum Frequency {
  WEEKLY
  FORTNIGHTLY
  MONTHLY
  ANNUAL
}

enum TransactionDirection {
  IN
  OUT
}

enum UserRole {
  OWNER       // Full permissions, billing, member management
  ADMIN       // Manage users and data, no billing/org deletion
  CONTRIBUTOR // Full access to financial entities, no user management
  VIEWER      // Read-only access

  // Legacy roles - kept for backward compatibility during migration
  PARTNER     // @deprecated - use CONTRIBUTOR instead
  ACCOUNTANT  // @deprecated - use VIEWER instead
}

enum DebtStrategy {
  TAX_AWARE_MINIMUM_INTEREST
  AVALANCHE
  SNOWBALL
}

// =============================================================================
// PHASE 5: SOURCE TYPE ENUMS
// =============================================================================

enum IncomeSourceType {
  GENERAL
  PROPERTY
  INVESTMENT
}

enum ExpenseSourceType {
  GENERAL
  PROPERTY
  LOAN
  INVESTMENT
}

// =============================================================================
// PHASE 10: AUTH & SECURITY ENUMS
// =============================================================================

enum MFAType {
  TOTP        // Google Authenticator, Authy
  SMS         // SMS fallback
  WEBAUTHN    // FIDO2, Passkeys, hardware keys
}

enum AuditAction {
  // Auth
  LOGIN
  LOGOUT
  MFA_CHALLENGE
  MFA_SUCCESS
  MFA_FAILURE
  PASSWORD_CHANGE
  PASSWORD_RESET

  // Passkey / WebAuthn
  PASSKEY_REGISTER
  PASSKEY_UPDATE
  PASSKEY_DELETE

  // CRUD operations
  CREATE
  READ
  UPDATE
  DELETE

  // Special operations
  EXPORT
  BULK_DELETE

  // Admin operations
  ROLE_CHANGE
  ORG_MEMBER_ADD
  ORG_MEMBER_REMOVE
  ORG_SETTINGS_UPDATE
  SESSION_REVOKE
  ACCOUNT_LOCK
  ACCOUNT_UNLOCK
  ACCOUNT_LOCKED
  ACCOUNT_UNLOCKED

  // Security
  RATE_LIMIT_HIT
  UNAUTHORIZED_ACCESS
  FORBIDDEN_ACCESS
}

enum AuditStatus {
  SUCCESS
  FAILURE
  BLOCKED
}

// =============================================================================
// USER
// =============================================================================

model User {
  id                String    @id @default(uuid())
  email             String    @unique
  password          String?   // Nullable for passwordless accounts
  name              String
  role              UserRole  @default(OWNER)
  emailVerified     Boolean   @default(false)
  emailVerifiedAt   DateTime?
  mfaEnabled        Boolean   @default(false)
  mfaEnforcedByOrg  Boolean   @default(false)
  accountLocked     Boolean   @default(false)
  accountLockedUntil DateTime?
  lastLoginAt       DateTime?
  lastLoginIp       String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relationships
  properties          Property[]
  loans               Loan[]
  accounts            Account[]
  income              Income[]
  expenses            Expense[]
  transactions        Transaction[]
  debtPlans           DebtPlan[]
  investmentAccounts  InvestmentAccount[]

  // Phase 10: Auth & Security
  organizationMemberships OrganizationMember[]
  mfaMethods              MFAMethod[]
  sessions                UserSession[]
  auditLogs               AuditLog[]
  passkeyCredentials      PasskeyCredential[]
  magicLinks              MagicLink[]
  oauthAccounts           OAuthAccount[]
  loginAttempts           LoginAttempt[]
  emailMFACodes           EmailMFACode[]

  // Phase 11: AI Strategy Engine
  strategyRecommendations StrategyRecommendation[]
  strategySessions        StrategySession[]
  strategyForecasts       StrategyForecast[]

  // Phase 13: Transactional Intelligence
  unifiedTransactions     UnifiedTransaction[]
  recurringPayments       RecurringPayment[]
  spendingProfile         SpendingProfile?

  @@map("users")
}

// =============================================================================
// PROPERTY
// =============================================================================

model Property {
  id             String       @id @default(uuid())
  userId         String
  name           String
  type           PropertyType
  address        String?
  purchasePrice  Float
  purchaseDate   DateTime
  currentValue   Float
  valuationDate  DateTime
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relationships
  user                  User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  loans                 Loan[]
  income                Income[]
  expenses              Expense[]
  depreciationSchedules DepreciationSchedule[]

  @@index([userId])
  @@map("properties")
}

// =============================================================================
// LOAN
// =============================================================================

model Loan {
  id                   String              @id @default(uuid())
  userId               String
  propertyId           String?
  offsetAccountId      String?             @unique
  name                 String
  type                 LoanType
  principal            Float               // Current balance
  interestRateAnnual   Float               // e.g., 0.0625 for 6.25%
  rateType             RateType
  fixedExpiry          DateTime?           // When fixed rate expires
  isInterestOnly       Boolean             @default(false)
  termMonthsRemaining  Int
  minRepayment         Float               // Current required payment
  repaymentFrequency   RepaymentFrequency
  extraRepaymentCap    Float?              // Annual cap for extra repayments on fixed loans
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt

  // Relationships
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  property       Property?    @relation(fields: [propertyId], references: [id], onDelete: SetNull)
  offsetAccount  Account?     @relation(fields: [offsetAccountId], references: [id], onDelete: SetNull)
  expenses       Expense[]
  debtPlanLoans  DebtPlanLoan[]

  @@index([userId])
  @@index([propertyId])
  @@map("loans")
}

// =============================================================================
// ACCOUNT
// =============================================================================

model Account {
  id             String       @id @default(uuid())
  userId         String
  name           String
  type           AccountType
  institution    String?
  currentBalance Float
  interestRate   Float?       // Annual interest rate (e.g., 0.025 for 2.5%)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relationships
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions Transaction[]
  linkedLoan   Loan?         // One-to-one: this account can be an offset for one loan

  // Phase 13: Transactional Intelligence
  unifiedTransactions UnifiedTransaction[] @relation("UnifiedTransactions")
  recurringPayments   RecurringPayment[]   @relation("RecurringPayments")

  @@index([userId])
  @@map("accounts")
}

// =============================================================================
// INCOME
// =============================================================================

model Income {
  id                    String            @id @default(uuid())
  userId                String
  propertyId            String?
  investmentAccountId   String?
  name                  String
  type                  IncomeType
  sourceType            IncomeSourceType  @default(GENERAL)
  amount                Float
  frequency             Frequency
  isTaxable             Boolean           @default(true)
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  // Relationships
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  property          Property?          @relation(fields: [propertyId], references: [id], onDelete: SetNull)
  investmentAccount InvestmentAccount? @relation(fields: [investmentAccountId], references: [id], onDelete: SetNull)
  transactions      Transaction[]

  @@index([userId])
  @@index([propertyId])
  @@index([investmentAccountId])
  @@map("income")
}

// =============================================================================
// EXPENSE
// =============================================================================

model Expense {
  id                    String             @id @default(uuid())
  userId                String
  propertyId            String?
  loanId                String?
  investmentAccountId   String?
  name                  String
  vendorName            String?
  category              ExpenseCategory
  sourceType            ExpenseSourceType  @default(GENERAL)
  amount                Float
  frequency             Frequency
  isEssential           Boolean            @default(true)
  isTaxDeductible       Boolean            @default(false)
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt

  // Relationships
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  property          Property?          @relation(fields: [propertyId], references: [id], onDelete: SetNull)
  loan              Loan?              @relation(fields: [loanId], references: [id], onDelete: SetNull)
  investmentAccount InvestmentAccount? @relation(fields: [investmentAccountId], references: [id], onDelete: SetNull)
  transactions      Transaction[]

  @@index([userId])
  @@index([propertyId])
  @@index([loanId])
  @@index([investmentAccountId])
  @@map("expenses")
}

// =============================================================================
// TRANSACTION
// =============================================================================

model Transaction {
  id          String               @id @default(uuid())
  userId      String
  accountId   String
  propertyId  String?
  loanId      String?
  incomeId    String?
  expenseId   String?
  date        DateTime
  description String
  amount      Float
  direction   TransactionDirection
  category    String?
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt

  // Relationships
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  account  Account   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  income   Income?   @relation(fields: [incomeId], references: [id], onDelete: SetNull)
  expense  Expense?  @relation(fields: [expenseId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([accountId])
  @@index([date])
  @@map("transactions")
}

// =============================================================================
// DEBT PLAN (Optional storage of debt planner results)
// =============================================================================

model DebtPlan {
  id                    String        @id @default(uuid())
  userId                String
  name                  String
  strategy              DebtStrategy
  surplusPerPeriod      Float
  surplusFrequency      Frequency
  emergencyBuffer       Float         @default(0)
  respectFixedCaps      Boolean       @default(true)
  rolloverRepayments    Boolean       @default(true)
  totalInterestPaid     Float
  totalInterestSaved    Float
  debtFreeDate          DateTime?
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  // Relationships
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  loanDetails DebtPlanLoan[]

  @@index([userId])
  @@map("debt_plans")
}

// =============================================================================
// DEBT PLAN LOAN (Per-loan results from debt planner)
// =============================================================================

model DebtPlanLoan {
  id                String    @id @default(uuid())
  debtPlanId        String
  loanId            String
  loanName          String
  originalPrincipal Float
  payoffDate        DateTime
  totalInterestPaid Float
  monthsSaved       Int
  interestSaved     Float
  createdAt         DateTime  @default(now())

  // Relationships
  debtPlan DebtPlan @relation(fields: [debtPlanId], references: [id], onDelete: Cascade)
  loan     Loan     @relation(fields: [loanId], references: [id], onDelete: Cascade)

  @@index([debtPlanId])
  @@index([loanId])
  @@map("debt_plan_loans")
}

// =============================================================================
// PHASE 3: INVESTMENT ENUMS
// =============================================================================

enum InvestmentAccountType {
  BROKERAGE
  SUPERS
  FUND
  TRUST
  ETF_CRYPTO
}

enum HoldingType {
  SHARE
  ETF
  MANAGED_FUND
  CRYPTO
}

enum InvestmentTransactionType {
  BUY
  SELL
  DIVIDEND
  DISTRIBUTION
  DRP
}

enum DepreciationCategory {
  DIV40
  DIV43
}

enum DepreciationMethod {
  PRIME_COST
  DIMINISHING_VALUE
}

// =============================================================================
// PHASE 3: INVESTMENT ACCOUNT
// =============================================================================

model InvestmentAccount {
  id           String                @id @default(uuid())
  userId       String
  name         String
  type         InvestmentAccountType
  platform     String?               // e.g. CommSec, SelfWealth, Betashares app
  currency     String                @default("AUD")
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt

  // Relationships
  user         User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  holdings     InvestmentHolding[]
  transactions InvestmentTransaction[]
  incomes      Income[]
  expenses     Expense[]

  @@index([userId])
  @@map("investment_accounts")
}

// =============================================================================
// PHASE 3: INVESTMENT HOLDING
// =============================================================================

model InvestmentHolding {
  id                  String            @id @default(uuid())
  investmentAccountId String
  ticker              String            // VAS, A200, VGS, BHP
  units               Float
  averagePrice        Float
  frankingPercentage  Float?            // AU feature for franking credits
  type                HoldingType
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  // Relationships
  investmentAccount   InvestmentAccount       @relation(fields: [investmentAccountId], references: [id], onDelete: Cascade)
  transactions        InvestmentTransaction[]

  @@index([investmentAccountId])
  @@map("investment_holdings")
}

// =============================================================================
// PHASE 3: INVESTMENT TRANSACTION
// =============================================================================

model InvestmentTransaction {
  id                  String                    @id @default(uuid())
  investmentAccountId String
  holdingId           String?
  date                DateTime
  type                InvestmentTransactionType
  price               Float
  units               Float
  fees                Float?
  notes               String?
  createdAt           DateTime                  @default(now())
  updatedAt           DateTime                  @updatedAt

  // Relationships
  investmentAccount   InvestmentAccount   @relation(fields: [investmentAccountId], references: [id], onDelete: Cascade)
  holding             InvestmentHolding?  @relation(fields: [holdingId], references: [id], onDelete: SetNull)

  @@index([investmentAccountId])
  @@index([holdingId])
  @@map("investment_transactions")
}

// =============================================================================
// PHASE 3: DEPRECIATION SCHEDULE
// =============================================================================

model DepreciationSchedule {
  id         String               @id @default(uuid())
  propertyId String
  category   DepreciationCategory
  assetName  String
  cost       Float
  startDate  DateTime
  rate       Float                // 2.5% for Div43, or effective life rate
  method     DepreciationMethod   // PRIME_COST | DIMINISHING_VALUE
  notes      String?
  createdAt  DateTime             @default(now())
  updatedAt  DateTime             @updatedAt

  // Relationships
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@index([propertyId])
  @@map("depreciation_schedules")
}

// =============================================================================
// PHASE 10: ORGANIZATION & MULTI-TENANT
// =============================================================================

model Organization {
  id                    String               @id @default(uuid())
  name                  String
  slug                  String               @unique
  description           String?
  mfaEnforced           Boolean              @default(false)
  sessionDurationHours  Int                  @default(168) // 7 days
  allowedDomains        String[]             // Email domain restrictions
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt

  // Relationships
  members               OrganizationMember[]
  auditLogs             AuditLog[]
  strategyRecommendations StrategyRecommendation[]

  @@map("organizations")
}

model OrganizationMember {
  id             String        @id @default(uuid())
  organizationId String
  userId         String
  role           UserRole      @default(VIEWER)
  invitedBy      String?       // User ID who sent the invitation
  invitedAt      DateTime      @default(now())
  joinedAt       DateTime?
  isActive       Boolean       @default(true)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // Relationships
  organization   Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId])
  @@index([organizationId])
  @@index([userId])
  @@map("organization_members")
}

// =============================================================================
// PHASE 10: MFA & AUTHENTICATION
// =============================================================================

model MFAMethod {
  id              String    @id @default(uuid())
  userId          String
  type            MFAType
  isEnabled       Boolean   @default(true)
  isPrimary       Boolean   @default(false)
  secret          String?   // For TOTP: encrypted secret
  phoneNumber     String?   // For SMS: phone number
  backupCodes     String[]  // Encrypted backup codes
  lastUsedAt      DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relationships
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("mfa_methods")
}

model PasskeyCredential {
  id                String    @id @default(uuid())
  userId            String
  credentialId      String    @unique // WebAuthn credential ID
  publicKey         String    // Public key for verification
  counter           Int       @default(0)
  deviceName        String?
  transports        String[]  // e.g., ["usb", "nfc", "ble"]
  lastUsedAt        DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relationships
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("passkey_credentials")
}

model UserSession {
  id              String    @id @default(uuid())
  userId          String
  token           String    @unique
  deviceName      String?
  deviceFingerprint String?
  ipAddress       String?
  userAgent       String?
  isActive        Boolean   @default(true)
  expiresAt       DateTime
  lastActivityAt  DateTime  @default(now())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relationships
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("user_sessions")
}

// =============================================================================
// PHASE 10: AUDIT LOGGING
// =============================================================================

model AuditLog {
  id              String         @id @default(uuid())
  userId          String?
  organizationId  String?
  action          AuditAction
  status          AuditStatus    @default(SUCCESS)
  entityType      String?        // "Property", "Loan", "User", etc.
  entityId        String?        // ID of the affected entity
  ipAddress       String?
  userAgent       String?
  metadata        Json?          // Additional context (old/new values, error details)
  createdAt       DateTime       @default(now())

  // Relationships
  user            User?          @relation(fields: [userId], references: [id], onDelete: SetNull)
  organization    Organization?  @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([organizationId])
  @@index([action])
  @@index([createdAt])
  @@index([entityType, entityId])
  @@map("audit_logs")
}

// =============================================================================
// PHASE 10: MAGIC LINK AUTHENTICATION
// =============================================================================

model MagicLink {
  id          String    @id @default(uuid())
  userId      String
  token       String    @unique
  email       String
  expiresAt   DateTime
  usedAt      DateTime?
  redirectTo  String?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime  @default(now())

  // Relationships
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("magic_links")
}

// =============================================================================
// PHASE 10: OAUTH ACCOUNTS
// =============================================================================

model OAuthAccount {
  id              String    @id @default(uuid())
  userId          String
  provider        String    // google, apple, microsoft
  providerUserId  String    // ID from OAuth provider
  email           String?
  accessToken     String?   @db.Text
  refreshToken    String?   @db.Text
  expiresAt       DateTime?
  scope           String?
  tokenType       String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relationships
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerUserId])
  @@index([userId])
  @@map("oauth_accounts")
}
// =============================================================================
// PHASE 10: LOGIN ATTEMPTS (for account lockout)
// =============================================================================

model LoginAttempt {
  id          String    @id @default(uuid())
  userId      String
  email       String
  success     Boolean
  ipAddress   String?
  userAgent   String?
  attemptedAt DateTime  @default(now())

  // Relationships
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([email])
  @@index([attemptedAt])
  @@map("login_attempts")
}

// =============================================================================
// PHASE 10: EMAIL MFA CODES
// =============================================================================

model EmailMFACode {
  id          String    @id @default(uuid())
  userId      String
  code        String    // SHA-256 hashed
  expiresAt   DateTime
  verified    Boolean   @default(false)
  verifiedAt  DateTime?
  attempts    Int       @default(0)
  createdAt   DateTime  @default(now())

  // Relationships
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([code])
  @@index([expiresAt])
  @@map("email_mfa_codes")
}

// =============================================================================
// PHASE 13: TRANSACTIONAL INTELLIGENCE ENUMS
// =============================================================================

enum TransactionSource {
  BANK        // Bank feed integration
  CSV         // CSV import
  OFX         // OFX/QFX file import
  MANUAL      // Manual entry
}

enum RecurrencePattern {
  WEEKLY
  FORTNIGHTLY
  MONTHLY
  QUARTERLY
  ANNUALLY
  IRREGULAR
}

enum AnomalyType {
  DUPLICATE           // Possible duplicate transaction
  UNUSUAL_AMOUNT      // Amount significantly differs from pattern
  NEW_MERCHANT        // First time seeing this merchant
  PRICE_INCREASE      // Recurring payment increased
  UNEXPECTED_CATEGORY // Category doesn't match merchant history
  TIMING_ANOMALY      // Transaction at unusual time/day
}

// =============================================================================
// PHASE 13: UNIFIED TRANSACTION RECORD (UTR)
// =============================================================================

model UnifiedTransaction {
  id                    String               @id @default(uuid())
  userId                String
  accountId             String

  // Core transaction data
  date                  DateTime
  postDate              DateTime?            // Settlement date
  amount                Float
  currency              String               @default("AUD")
  direction             TransactionDirection

  // Merchant data
  merchantRaw           String?              // Original merchant string from source
  merchantStandardised  String?              // Normalised merchant name
  merchantCategoryCode  String?              // MCC code if available
  description           String               // Transaction description

  // Category hierarchy (AI + rules populated)
  categoryLevel1        String?              // Top-level: "Food & Dining"
  categoryLevel2        String?              // Sub-category: "Groceries"
  subcategory           String?              // Detailed: "Supermarket"

  // User interaction
  tags                  String[]             // User/system tags
  userCorrectedCategory Boolean              @default(false)
  confidenceScore       Float?               // AI categorisation confidence (0-1)

  // Recurring detection
  isRecurring           Boolean              @default(false)
  recurrencePattern     RecurrencePattern?
  recurrenceGroupId     String?              // Links recurring transactions together

  // Anomaly detection
  anomalyFlags          AnomalyType[]

  // Source tracking
  source                TransactionSource    @default(MANUAL)
  externalId            String?              // ID from external source (bank, CSV row)
  importBatchId         String?              // Batch ID for grouped imports

  // Entity linking (GRDCS compatible)
  propertyId            String?
  loanId                String?
  incomeId              String?
  expenseId             String?
  investmentAccountId   String?

  // Metadata
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
  processedAt           DateTime?            // When TIE last processed this

  // Relationships
  user                  User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  account               Account              @relation("UnifiedTransactions", fields: [accountId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([accountId])
  @@index([date])
  @@index([merchantStandardised])
  @@index([categoryLevel1])
  @@index([isRecurring])
  @@index([recurrenceGroupId])
  @@index([source])
  @@index([processedAt])
  @@map("unified_transactions")
}

// =============================================================================
// PHASE 13: MERCHANT MAPPING (Learning from corrections)
// =============================================================================

model MerchantMapping {
  id                    String    @id @default(uuid())
  userId                String?   // Null = global mapping, set = user-specific

  // Merchant identification
  merchantRaw           String    // Original merchant string pattern
  merchantStandardised  String    // Normalised name
  merchantCategoryCode  String?   // MCC if known

  // Category mapping
  categoryLevel1        String
  categoryLevel2        String?
  subcategory           String?

  // Learning metadata
  confidence            Float     @default(1.0)   // How confident this mapping is
  source                String    @default("RULE") // RULE, USER, AI
  usageCount            Int       @default(0)     // How many times applied

  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@unique([userId, merchantRaw])
  @@index([merchantRaw])
  @@index([userId])
  @@map("merchant_mappings")
}

// =============================================================================
// PHASE 13: RECURRING PAYMENT DETECTION
// =============================================================================

model RecurringPayment {
  id                    String            @id @default(uuid())
  userId                String

  // Identification
  merchantStandardised  String
  accountId             String

  // Pattern
  pattern               RecurrencePattern
  expectedAmount        Float
  amountVariance        Float             @default(0.05) // 5% variance tolerance

  // Tracking
  lastOccurrence        DateTime
  nextExpected          DateTime?
  occurrenceCount       Int               @default(0)

  // Alerts
  priceIncreaseAlert    Boolean           @default(false)
  lastPriceChange       Float?
  lastPriceChangeDate   DateTime?

  // Status
  isActive              Boolean           @default(true)
  isPaused              Boolean           @default(false)

  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  // Relationships
  user                  User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  account               Account           @relation("RecurringPayments", fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([userId, merchantStandardised, accountId])
  @@index([userId])
  @@index([accountId])
  @@index([nextExpected])
  @@map("recurring_payments")
}

// =============================================================================
// PHASE 13: BEHAVIOURAL PROFILE
// =============================================================================

model SpendingProfile {
  id                    String    @id @default(uuid())
  userId                String    @unique

  // Category averages (JSON: { category: { avgMonthly, trend, volatility } })
  categoryAverages      Json

  // Monthly patterns (JSON: { month: { totalSpend, categories } })
  monthlyPatterns       Json?

  // Seasonality detection
  seasonalityFactors    Json?     // { category: { jan: 1.2, feb: 0.9, ... } }

  // Spending clusters (AI-detected patterns)
  spendingClusters      Json?     // [{ name, merchants, avgMonthly }]

  // Volatility metrics
  overallVolatility     Float     @default(0)
  categoryVolatility    Json?     // { category: volatilityScore }

  // Prediction data
  predictedMonthlySpend Float?
  predictionConfidence  Float?

  // Metadata
  dataPointCount        Int       @default(0)
  lastCalculated        DateTime  @default(now())
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relationships
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("spending_profiles")
}

// =============================================================================
// PHASE 11: AI STRATEGY ENGINE ENUMS
// =============================================================================

enum StrategyCategory {
  GROWTH
  DEBT
  CASHFLOW
  INVESTMENT
  PROPERTY
  RISK_RESILIENCE
}

enum StrategyType {
  TACTICAL        // Immediate action
  OPERATIONAL     // 3-12 months
  STRATEGIC       // 1-5 years
  LONG_TERM       // 5-30 years
}

enum RecommendationStatus {
  PENDING
  ACCEPTED
  DISMISSED
  EXPIRED
}

enum ConfidenceLevel {
  HIGH
  MEDIUM
  LOW
}

enum RiskAppetite {
  CONSERVATIVE
  MODERATE
  AGGRESSIVE
}

enum DebtComfort {
  DEBT_AVERSE
  MODERATE
  LEVERAGE_COMFORTABLE
}

enum InvestmentStyle {
  PASSIVE
  BALANCED
  ACTIVE
}

enum ScenarioType {
  DEFAULT
  CONSERVATIVE
  AGGRESSIVE
  CUSTOM
}

// =============================================================================
// PHASE 11: STRATEGY RECOMMENDATION
// =============================================================================

model StrategyRecommendation {
  id                String               @id @default(uuid())
  userId            String
  organizationId    String?

  // Classification
  category          StrategyCategory
  type              StrategyType
  severity          String               // 'critical' | 'high' | 'medium' | 'low' (from InsightSeverity)

  // Content
  title             String
  summary           String               @db.Text
  detail            String               @db.Text

  // Scoring
  sbsScore          Float                // Strategic Benefit Score (0-100)
  confidence        ConfidenceLevel

  // Impact Analysis (stored as JSON for flexibility)
  financialImpact   Json                 // { min, max, currency, timeframe, monthlySavings, totalSavings, breakEven }
  riskImpact        Json                 // { current, projected, factors[] }
  liquidityImpact   Json?                // { currentLiquidity, projectedLiquidity, impact }
  taxImpact         Json?                // { currentTax, projectedTax, savings }

  // Evidence & Explainability
  reasoning         String               @db.Text  // Step-by-step reasoning trace
  evidenceGraph     Json                 // { dataPoints[], historicalTrend[], snapshotValues, insightFlags[], healthIssues[], calculations }
  alternativeIds    String[]             // IDs of alternative strategies

  // Affected Entities (GRDCS format)
  affectedEntities  Json                 // GRDCSLinkedEntity[] - entities impacted by this recommendation

  // Forecast Projection (optional)
  forecastData      Json?                // Multi-year projection if applicable

  // User Interaction
  status            RecommendationStatus @default(PENDING)
  dismissedAt       DateTime?
  acceptedAt        DateTime?
  dismissReason     String?

  // Metadata
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  expiresAt         DateTime?            // When this recommendation becomes stale

  // Relationships
  user              User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization      Organization?        @relation(fields: [organizationId], references: [id])

  @@index([userId, status])
  @@index([organizationId])
  @@index([category, status])
  @@index([sbsScore])
  @@index([createdAt])
  @@map("strategy_recommendations")
}

// =============================================================================
// PHASE 11: STRATEGY SESSION (User Preferences)
// =============================================================================

model StrategySession {
  id                String            @id @default(uuid())
  userId            String

  version           Int               @default(1)

  // User Input Parameters
  riskAppetite      RiskAppetite?
  timeHorizon       Int?              // Years (e.g., 5, 10, 20, 30)
  debtComfort       DebtComfort?
  investmentStyle   InvestmentStyle?
  retirementAge     Int?              // Target retirement age

  // Scenario Selection
  scenarioType      ScenarioType      @default(DEFAULT)
  customParameters  Json?             // Custom forecast parameters if scenarioType = CUSTOM

  // Tracking
  acceptedCount     Int               @default(0)
  dismissedCount    Int               @default(0)

  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // Relationships
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("strategy_sessions")
}

// =============================================================================
// PHASE 11: STRATEGY FORECAST (Multi-Year Projections)
// =============================================================================

model StrategyForecast {
  id                String        @id @default(uuid())
  userId            String

  // Forecast Parameters
  startYear         Int           // Starting year (e.g., 2025)
  endYear           Int           // Ending year (e.g., 2055 for 30-year forecast)
  scenarioType      ScenarioType

  // Input Assumptions
  incomeGrowthRate  Float         // Annual income growth rate (e.g., 0.03 for 3%)
  expenseInflation  Float         // Annual expense inflation (e.g., 0.025 for 2.5%)
  investmentReturn  Float         // Expected annual investment return (e.g., 0.07 for 7%)
  rentalYield       Float         // Expected rental yield (e.g., 0.04 for 4%)
  cpiProjection     Float         // CPI inflation projection (e.g., 0.025 for 2.5%)

  // Yearly Projections (array of year data stored as JSON)
  projections       Json          // [{ year, netWorth, debt, cashflow, income, expenses, investments, properties }]

  // Risk Bands (best/worst case scenarios)
  worstCase         Json          // Worst case projection array
  bestCase          Json          // Best case projection array

  // Target Achievement
  targetProbability Float?        // Probability of achieving retirement/goal target (0-1)

  createdAt         DateTime      @default(now())

  // Relationships
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([scenarioType])
  @@index([createdAt])
  @@map("strategy_forecasts")
}
